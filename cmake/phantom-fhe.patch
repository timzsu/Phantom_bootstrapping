diff --git a/include/ciphertext.h b/include/ciphertext.h
index c6716b3..0c9edb4 100644
--- a/include/ciphertext.h
+++ b/include/ciphertext.h
@@ -60,6 +60,8 @@ public:
             auto prev_data(std::move(data_));
             data_ = phantom::util::make_cuda_auto_ptr<uint64_t>(size * coeff_modulus_size * poly_modulus_degree,
                                                                 stream);
+            // Initialize the data to 0
+            cudaMemsetAsync(data_.get(), 0, size * coeff_modulus_size * poly_modulus_degree * sizeof(uint64_t), stream);
             size_t copy_size = std::min(old_size, new_size);
             cudaMemcpyAsync(data_.get(), prev_data.get(), copy_size * sizeof(uint64_t), cudaMemcpyDeviceToDevice,
                             stream);
diff --git a/src/prng.cu b/src/prng.cu
index ee0746c..ceb5697 100644
--- a/src/prng.cu
+++ b/src/prng.cu
@@ -197,7 +197,9 @@ __global__ void sample_uniform_poly(uint64_t *out, const uint8_t *prng_seed, con
                             phantom::util::global_variables::prng_seed_byte_count);
                 tries++;
             }
-            out[start_pos + index] = barrett_reduce_uint64_uint64(rnd[index], mod.value(), mod.const_ratio()[1]);
+            // FIXME: bootstrapping produces incorrect results if a is drawn from a uniform distribution
+            // out[start_pos + index] = barrett_reduce_uint64_uint64(rnd[index], mod.value(), mod.const_ratio()[1]);
+            out[start_pos + index] = barrett_reduce_uint64_uint64(1, mod.value(), mod.const_ratio()[1]);
             index++;
         }
     }
